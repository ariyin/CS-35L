#include "output.h"
#include <limits.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

bool
writebytes (unsigned long long x, int nbytes)
{
    do
    {
        if (putchar (x) < 0)
	        return false;
        x >>= CHAR_BIT;
        nbytes--;
    }
    while (0 < nbytes);

    return true;
}

int
handleOutput(unsigned long long (*rand64) (void), bool stdio, long long nbytes, unsigned int nInt)
{
    // Determine the size of the return type of rand64 function
    int wordsize = sizeof rand64 ();
    int output_errno = 0;

    // stdio
    if(stdio)
    {
        // Loop until nbytes becomes 0
        do
        {
            // Generate a random unsigned long long value
            unsigned long long x = rand64 ();

            // Determine the number of bytes to output (minimum of nbytes and wordsize)
            int outbytes = nbytes < wordsize ? nbytes : wordsize; 
            
            // If writing the generated bytes to stdout fails
            if (!writebytes (x, outbytes))
            {
                output_errno = errno;
                break;
            }
            nbytes -= outbytes;
        }
        while (0 < nbytes);

        // If unable to close the standard output stream (stdout)
        if (fclose (stdout) != 0)
            output_errno = errno;

        // Print error
        if (output_errno)
        {
            errno = output_errno;
            perror("output");
            return 1;
        }
    }

    else
    {
        unsigned long long x;
        char* buffer = malloc(nInt);
        int outbytes;
        long long bufSize = nInt; 

        // Loop until nbytes becomes 0
        do 
        {
            // Determine the number of bytes to output (minimum of nbytes and bufSize)
            outbytes = nbytes < bufSize ? nbytes : bufSize;

            // Loop over the buffer to fill it with random bytes
            for (size_t k = 0; k < outbytes; k+= sizeof(x))
            {
                x = rand64();

                // Loop over the bytes of x to copy them to the buffer
                for (size_t i = 0; i < sizeof(x); i++)
                {
                    // Break the loop if the total number of bytes written reaches outbytes
                    if (i + k >= outbytes)
                    {
                        break;
                    }

                    // Extract individual bytes from the random value and store in the buffer
                    unsigned char byte= *((unsigned char *)&x + i);
                    buffer[k + i] = byte;
                }
            }

            // Write the buffer to the standard output (file descriptor 1)
            int written = write(1, buffer, outbytes);

            // If error writing to the buffer
            if (written == -1)
            {
                free(buffer);
                fprintf(stderr, "Error while writing bytes\n");
                return 1;
            }
            nbytes -= written;
        }
        while (0 < nbytes);
    
        free(buffer);
    }

    // Return any errors, if any
    return output_errno;
}